{"version":3,"file":"AnimationBlocker.js","mappings":"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","sources":["webpack://Craft/webpack/bootstrap","webpack://Craft/webpack/runtime/define property getters","webpack://Craft/webpack/runtime/hasOwnProperty shorthand","webpack://Craft/webpack/runtime/make namespace object","webpack://Craft/./AnimationBlocker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var _a, _AnimationBlocker_imageAddedObserver;\nexport class AnimationBlocker {\n    constructor() {\n        _AnimationBlocker_imageAddedObserver.set(this, _a.createImageAddedObserver());\n        _a.hideAllAnimations();\n    }\n    /**\n     * Creates a MutationObserver to watch for added images\n     * @private\n     */\n    static createImageAddedObserver() {\n        const targetNode = document.querySelector('body');\n        // Options for the observer (which mutations to observe)\n        const config = { attributes: true, childList: true, subtree: true };\n        // Callback function to execute when mutations are observed\n        const callback = (mutationList) => {\n            for (const mutation of mutationList) {\n                if (mutation.type === 'childList') {\n                    if (mutation.addedNodes) {\n                        for (const node of mutation.addedNodes) {\n                            if (node.nodeName === 'IMG') {\n                                if (this.couldBeAnimated(node)) {\n                                    this.hideAnimation(node);\n                                }\n                            }\n                        }\n                    }\n                    if (mutation.removedNodes.length > 0) {\n                        mutation.removedNodes.forEach((removedNode) => {\n                            if (removedNode.nodeName === 'IMG') {\n                                if (this.couldBeAnimated(removedNode)) {\n                                    this.removeBlockerUI(mutation.target);\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n        };\n        // Create an observer instance linked to the callback function\n        const observer = new MutationObserver(callback);\n        // Start observing the target node for configured mutations\n        observer.observe(targetNode, config);\n        return observer;\n    }\n    /**\n     * Waits for an image to load\n     * @param image\n     * @private\n     */\n    static async waitForImage(image) {\n        return new Promise((res) => {\n            if (image.complete) {\n                return res();\n            }\n            image.onload = () => res();\n            image.onerror = () => res();\n        });\n    }\n    /**\n     * Checks if the image's size has changed\n     * @param image\n     * @private\n     */\n    static imageSizeChanged(image) {\n        const width = image.clientWidth;\n        const height = image.clientHeight;\n        const prevWidth = image.dataset.width;\n        const prevHeight = image.dataset.height;\n        if (!prevWidth || !prevHeight)\n            return;\n        return (width !== parseInt(prevWidth, 10) || height !== parseInt(prevHeight, 10));\n    }\n    /**\n     * Creates a canvas to cover the image\n     * @param image\n     * @private\n     */\n    static createCover(image) {\n        if (this.getCover(image))\n            return;\n        const width = image.clientWidth;\n        const height = image.clientHeight;\n        const parent = image.parentElement;\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        canvas.setAttribute('aria-hidden', 'true');\n        canvas.setAttribute('role', 'presentation');\n        canvas.setAttribute('data-image-cover', 'true');\n        canvas.style.position = 'absolute';\n        canvas.style.top = '50%';\n        canvas.style.left = '50%';\n        canvas.style.transform = 'translate(-50%, -50%)';\n        // Draw first frame on canvas\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(image, 0, 0, width, height);\n        parent.style.position = 'relative';\n        parent.insertBefore(canvas, image);\n    }\n    /**\n     * Gets the canvas cover\n     * @param image\n     * @private\n     */\n    static getCover(image) {\n        var _b;\n        return (_b = image.parentElement) === null || _b === void 0 ? void 0 : _b.querySelector('[data-image-cover]');\n    }\n    /**\n     * Removes the canvas cover\n     * @param image\n     * @private\n     */\n    static removeCover(image) {\n        const cover = this.getCover(image);\n        cover.parentElement.removeChild(cover);\n    }\n    static removeBlockerUI(mutationTarget) {\n        var _b;\n        (_b = mutationTarget.querySelector('[data-image-cover]')) === null || _b === void 0 ? void 0 : _b.remove();\n    }\n    /**\n     * Hides the animation of an image by drawing the first frame on a canvas\n     * @param image\n     */\n    static async hideAnimation(image) {\n        // If image already has an animation controller, return\n        if (image.dataset.animationController)\n            return;\n        // Wait until it's completely loaded\n        await this.waitForImage(image);\n        const parent = image.parentElement;\n        let canvas = parent.querySelector('[data-image-cover]');\n        const width = image.clientWidth;\n        const height = image.clientHeight;\n        // Store state on image\n        image.setAttribute('data-animation-state', 'paused');\n        if (!canvas) {\n            image.setAttribute('data-width', width.toString());\n            image.setAttribute('data-height', height.toString());\n            this.createCover(image);\n        }\n        else if (canvas && this.imageSizeChanged(image)) {\n            // Replace canvas\n            this.removeCover(image);\n            this.createCover(image);\n        }\n        image.dataset.animationController = JSON.stringify(this);\n    }\n    /**\n     * Hides the animation of all images on the page\n     */\n    static hideAllAnimations() {\n        const images = this.getAllPotentiallyAnimated();\n        for (let i = 0; i < images.length; i++) {\n            this.hideAnimation(images[i]);\n        }\n    }\n    /**\n     * Filters a NodeList of images to only include those that could be animated\n     */\n    static filterImages(images) {\n        return Array.from(images).filter((image) => this.couldBeAnimated(image));\n    }\n    /**\n     * Checks a given image's src and srcset for common animation extensions\n     * @param image\n     */\n    static couldBeAnimated(image) {\n        const src = image.src;\n        const srcset = image.srcset;\n        const hasExpectedExtension = this.extensions.some((extension) => src.includes(extension) || srcset.includes(extension));\n        return hasExpectedExtension || image.hasAttribute('data-animated');\n    }\n    static getAllPotentiallyAnimated() {\n        const allImages = document.querySelectorAll('img');\n        return this.filterImages(allImages);\n    }\n}\n_a = AnimationBlocker, _AnimationBlocker_imageAddedObserver = new WeakMap();\nAnimationBlocker.extensions = ['.gif', '.webp'];\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","_a","_AnimationBlocker_imageAddedObserver","AnimationBlocker","constructor","set","this","createImageAddedObserver","hideAllAnimations","targetNode","document","querySelector","observer","MutationObserver","mutationList","mutation","type","addedNodes","node","nodeName","couldBeAnimated","hideAnimation","removedNodes","length","forEach","removedNode","removeBlockerUI","target","observe","attributes","childList","subtree","waitForImage","image","Promise","res","complete","onload","onerror","imageSizeChanged","width","clientWidth","height","clientHeight","prevWidth","dataset","prevHeight","parseInt","createCover","getCover","parent","parentElement","canvas","createElement","setAttribute","style","position","top","left","transform","getContext","drawImage","insertBefore","_b","removeCover","cover","removeChild","mutationTarget","remove","animationController","toString","JSON","stringify","images","getAllPotentiallyAnimated","i","filterImages","Array","from","filter","src","srcset","extensions","some","extension","includes","hasAttribute","allImages","querySelectorAll","WeakMap"],"sourceRoot":""}