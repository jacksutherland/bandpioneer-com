{"version":3,"file":"AssetIndexer.js","mappings":"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","sources":["webpack://Craft/webpack/bootstrap","webpack://Craft/webpack/runtime/define property getters","webpack://Craft/webpack/runtime/hasOwnProperty shorthand","webpack://Craft/webpack/runtime/make namespace object","webpack://Craft/./AssetIndexer.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var SessionStatus;\n(function (SessionStatus) {\n    SessionStatus[SessionStatus[\"ACTIONREQUIRED\"] = 0] = \"ACTIONREQUIRED\";\n    SessionStatus[SessionStatus[\"ACTIVE\"] = 1] = \"ACTIVE\";\n    SessionStatus[SessionStatus[\"WAITING\"] = 2] = \"WAITING\";\n})(SessionStatus || (SessionStatus = {}));\nvar IndexingActions;\n(function (IndexingActions) {\n    IndexingActions[\"START\"] = \"asset-indexes/start-indexing\";\n    IndexingActions[\"STOP\"] = \"asset-indexes/stop-indexing-session\";\n    IndexingActions[\"PROCESS\"] = \"asset-indexes/process-indexing-session\";\n    IndexingActions[\"OVERVIEW\"] = \"asset-indexes/indexing-session-overview\";\n    IndexingActions[\"FINISH\"] = \"asset-indexes/finish-indexing-session\";\n})(IndexingActions || (IndexingActions = {}));\n/**\n * Actual classes start here\n */\n// Asset Indexer\n// =====================================================================================\nexport class AssetIndexer {\n    /**\n     * @param $element The indexing session table\n     * @param sessions Existing indexing sessions\n     */\n    constructor($indexingSessionTable, sessions, maxConcurrentConnections = 3) {\n        this._currentIndexingSession = null;\n        this._currentConnectionCount = 0;\n        this._tasksWaiting = [];\n        this._priorityTasks = [];\n        this._prunedSessionIds = [];\n        this._currentlyReviewing = false;\n        this.intervalAnnouncer = null;\n        this.indexingSessions = {};\n        this._maxConcurrentConnections = maxConcurrentConnections;\n        this.$indexingSessionTable = $indexingSessionTable;\n        this.indexingSessions = {};\n        let reviewSessionId = 0;\n        for (const sessionModel of sessions) {\n            let session = this.createSessionFromModel(sessionModel);\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED &&\n                !reviewSessionId) {\n                reviewSessionId = session.getSessionId();\n            }\n            if (!reviewSessionId &&\n                this._currentIndexingSession == null &&\n                session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n            }\n            this.updateIndexingSessionData(session);\n        }\n        if (this._currentIndexingSession) {\n            this._createProgressAnnouncer();\n            this._startProgressAnnouncer();\n            this.performIndexingStep();\n        }\n    }\n    get currentIndexingSession() {\n        return this._currentIndexingSession;\n    }\n    /**\n     * Get progress info for the current session\n     */\n    getCurrentSessionProgressInfo() {\n        if (this.currentIndexingSession !== null) {\n            const session = this.indexingSessions[this.currentIndexingSession];\n            return session.getProgressInfo();\n        }\n        return null;\n    }\n    /**\n     * Update indexing session store\n     * @param session\n     */\n    updateIndexingSessionData(indexingSession) {\n        this.indexingSessions[indexingSession.getSessionId()] = indexingSession;\n        this.renderIndexingSessionRow(indexingSession);\n    }\n    /**\n     * Return a rendered indexing session row based on its id\n     * @param sessionId\n     */\n    renderIndexingSessionRow(session) {\n        let $row;\n        if (session === undefined) {\n            return;\n        }\n        if (!this.indexingSessions[session.getSessionId()] ||\n            this._prunedSessionIds.includes(session.getSessionId())) {\n            this.$indexingSessionTable\n                .find('tr[data-session-id=\"' + session.getSessionId() + '\"]')\n                .remove();\n            if (this.$indexingSessionTable.find('tbody tr').length == 0) {\n                this.$indexingSessionTable.addClass('hidden');\n            }\n            return;\n        }\n        $row = session.getIndexingSessionRowHtml();\n        const $existing = this.$indexingSessionTable.find('tr[data-session-id=\"' + session.getSessionId() + '\"]');\n        if ($existing.length > 0) {\n            $existing.replaceWith($row);\n        }\n        else {\n            this.$indexingSessionTable.find('tbody').append($row);\n        }\n        this.$indexingSessionTable.removeClass('hidden');\n    }\n    /**\n     * Remove an indexing session\n     * @param sessionId\n     * @protected\n     */\n    discardIndexingSession(sessionId) {\n        const session = this.indexingSessions[sessionId];\n        delete this.indexingSessions[sessionId];\n        if (this._currentIndexingSession === sessionId) {\n            this._currentIndexingSession = null;\n        }\n        this.renderIndexingSessionRow(session);\n        this.runTasks();\n    }\n    /**\n     * Process a failed indexing response.\n     *\n     * @param response\n     */\n    processFailureResponse(response) {\n        const responseData = response.data;\n        this._currentConnectionCount--;\n        this._updateCurrentIndexingSession();\n        Craft.cp.displayError(responseData.message);\n        if (responseData.stop) {\n            this.discardIndexingSession(responseData.stop);\n        }\n        // A mere error shall not stop the party.\n        this.runTasks();\n        return;\n    }\n    /**\n     * Process a successful indexing response.\n     *\n     * @param response\n     */\n    processSuccessResponse(response) {\n        const responseData = response.data;\n        this._currentConnectionCount--;\n        if (responseData.session) {\n            const session = this.createSessionFromModel(responseData.session);\n            this.indexingSessions[session.getSessionId()] = session;\n            this.renderIndexingSessionRow(session);\n            this._updateCurrentIndexingSession();\n            if (session.getSessionStatus() === SessionStatus.ACTIONREQUIRED &&\n                !responseData.skipDialog) {\n                if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                    this.reviewSession(session);\n                }\n                else {\n                    this.runTasks();\n                }\n            }\n            else if (!this._prunedSessionIds.includes(this._currentIndexingSession)) {\n                this.performIndexingStep();\n            }\n            else {\n                this.runTasks();\n            }\n        }\n        this._updateCurrentIndexingSession();\n        if (responseData.stop) {\n            this.discardIndexingSession(responseData.stop);\n        }\n    }\n    getReviewData(session) {\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.OVERVIEW,\n            params: { sessionId: session.getSessionId() },\n            callback: () => {\n                this.renderIndexingSessionRow(session);\n            },\n        };\n        this.enqueueTask(task);\n    }\n    reviewSession(session) {\n        if (this._currentlyReviewing) {\n            return;\n        }\n        this._stopProgressAnnouncer();\n        this._currentlyReviewing = true;\n        this.pruneWaitingTasks(session.getSessionId());\n        let $confirmBody = $('<div></div>');\n        const missingEntries = session.getMissingEntries();\n        const missingFiles = missingEntries.files\n            ? Object.entries(missingEntries.files)\n            : [];\n        const missingFolders = missingEntries.folders\n            ? Object.entries(missingEntries.folders)\n            : [];\n        const skippedFiles = session.getSkippedEntries();\n        if (skippedFiles.length) {\n            let skippedFilesList = '';\n            for (const skippedFile of skippedFiles) {\n                skippedFilesList += `<li>${Craft.escapeHtml(skippedFile)}</li>`;\n            }\n            $confirmBody.append(`\n                <h2>${Craft.t('app', 'Skipped files')}</h2>\n                <p>${Craft.t('app', 'The following items were not indexed.')}</p>\n                <ul>\n                    ${skippedFilesList}\n                </ul>\n            `);\n        }\n        const haveMissingItems = missingFiles.length || missingFolders.length;\n        if (haveMissingItems) {\n            if (missingFolders.length) {\n                let missingEntries = '';\n                for (const [id, uri] of missingFolders) {\n                    missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteFolder[]\" value=\"${id}\"> ${Craft.escapeHtml(uri)}</label></li>`;\n                }\n                const translationParams = { items: 'folders' };\n                let missingItemsHeading = this._getMissingItemsHeading('folders', translationParams, session);\n                let missingItemsCopy = this._getMissingItemsCopy('folders', translationParams, session);\n                $confirmBody.append($(`\n                <h2>${missingItemsHeading}</h2>\n                <p>${missingItemsCopy}</p>\n                <ul>\n                    ${missingEntries}\n                </ul>\n            `));\n            }\n            if (missingFiles.length) {\n                let missingEntries = '';\n                for (const [id, uri] of missingFiles) {\n                    missingEntries += `<li><label><input type=\"checkbox\" checked=\"checked\" name=\"deleteAsset[]\" value=\"${id}\"> ${Craft.escapeHtml(uri)}</label></li>`;\n                }\n                const translationParams = { items: 'files' };\n                let missingItemsHeading = this._getMissingItemsHeading('files', translationParams, session);\n                let missingItemsCopy = this._getMissingItemsCopy('files', translationParams, session);\n                $confirmBody.append($(`\n                <h2>${missingItemsHeading}</h2>\n                <p>${missingItemsCopy}</p>\n                <ul>\n                    ${missingEntries}\n                </ul>\n            `));\n            }\n        }\n        const $modal = $('<form class=\"modal fitted confirmmodal\"/>').appendTo(Garnish.$bod);\n        const $body = $('<div class=\"body\"/>')\n            .appendTo($modal)\n            .html($confirmBody.html());\n        const $footer = $('<footer class=\"footer\"/>').appendTo($modal);\n        const $buttons = $('<div class=\"buttons right\"/>').appendTo($footer);\n        const modal = new Garnish.Modal($modal, {\n            hideOnEsc: false,\n            hideOnShadeClick: false,\n            onHide: () => {\n                this._currentlyReviewing = false;\n            },\n        });\n        if (haveMissingItems) {\n            let $cancelBtn = $('<button/>', {\n                type: 'button',\n                class: 'btn',\n                text: Craft.t('app', 'Keep them'),\n            })\n                .on('click', (ev) => {\n                ev.preventDefault();\n                this.stopIndexingSession(session);\n                modal.hide();\n            })\n                .appendTo($buttons);\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'Delete them'),\n            }).appendTo($buttons);\n        }\n        else {\n            $('<button/>', {\n                type: 'submit',\n                class: 'btn submit',\n                text: Craft.t('app', 'OK'),\n            }).appendTo($buttons);\n        }\n        Craft.initUiElements($body);\n        modal.updateSizeAndPosition();\n        $modal.on('submit', (ev) => {\n            ev.preventDefault();\n            modal.hide();\n            const postData = Garnish.getPostData($body);\n            const postParams = Craft.expandPostArray(postData);\n            postParams.sessionId = session.getSessionId();\n            // Make this the next task for sure?\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.FINISH,\n                params: postParams,\n            };\n            this.enqueueTask(task, true);\n        });\n    }\n    _getMissingItemsHeading(missingType, translationParams, session) {\n        let missingItemsHeading = Craft.t('app', 'Missing {items}', translationParams);\n        if (missingType == 'folders' && session.getListEmptyFolders()) {\n            missingItemsHeading = Craft.t('app', 'Missing or empty {items}', translationParams);\n        }\n        return missingItemsHeading;\n    }\n    _getMissingItemsCopy(missingType, translationParams, session) {\n        let missingItemsCopy = Craft.t('app', 'The following {items} could not be found. Should they be deleted from the index?', translationParams);\n        if (missingType == 'folders' && session.getListEmptyFolders()) {\n            missingItemsCopy = Craft.t('app', 'The following {items} could not be found or are empty. Should they be deleted from the index?', translationParams);\n        }\n        return missingItemsCopy;\n    }\n    startIndexing(data, cb) {\n        Craft.sendActionRequest('POST', IndexingActions.START, { data })\n            .then((response) => this.processSuccessResponse(response))\n            .catch(({ response }) => this.processFailureResponse(response))\n            .finally(() => cb());\n        // Begin making intermittent announcements\n        if (!this.intervalAnnouncer) {\n            this._createProgressAnnouncer();\n            this._startProgressAnnouncer();\n        }\n    }\n    _createProgressAnnouncer() {\n        this.intervalAnnouncer = new Craft.IntervalManager({\n            onInterval: () => {\n                if (this.currentIndexingSession !== null) {\n                    Craft.cp.announce(Craft.t('app', 'Indexing assets: {progress}', {\n                        progress: this.getCurrentSessionProgressInfo(),\n                    }));\n                }\n            },\n        });\n    }\n    _stopProgressAnnouncer() {\n        var _a;\n        (_a = this.intervalAnnouncer) === null || _a === void 0 ? void 0 : _a.stop();\n    }\n    _startProgressAnnouncer() {\n        var _a;\n        (_a = this.intervalAnnouncer) === null || _a === void 0 ? void 0 : _a.start();\n    }\n    performIndexingStep() {\n        if (!this._currentIndexingSession) {\n            this._updateCurrentIndexingSession();\n        }\n        if (!this._currentIndexingSession) {\n            return;\n        }\n        const session = this.indexingSessions[this._currentIndexingSession];\n        const concurrentSlots = this._maxConcurrentConnections - this._currentConnectionCount;\n        // Queue up at least enough tasks to use up all the free connections of finish the session.\n        for (let i = 0; i < Math.min(concurrentSlots, session.getEntriesRemaining()); i++) {\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.PROCESS,\n                params: { sessionId: this._currentIndexingSession },\n            };\n            this.enqueueTask(task);\n        }\n        if (session.getProcessIfRootEmpty()) {\n            const task = {\n                sessionId: session.getSessionId(),\n                action: IndexingActions.PROCESS,\n                params: { sessionId: this._currentIndexingSession },\n            };\n            this.enqueueTask(task);\n        }\n    }\n    /**\n     * Stop and discard an indexing session.\n     *\n     * @param session\n     */\n    stopIndexingSession(session) {\n        this.pruneWaitingTasks(session.getSessionId());\n        const task = {\n            sessionId: session.getSessionId(),\n            action: IndexingActions.STOP,\n            params: { sessionId: session.getSessionId() },\n        };\n        this.enqueueTask(task, true);\n    }\n    /**\n     * Pune the waiting task list by removing all tasks for a session id.\n     *\n     * @param sessionId\n     */\n    pruneWaitingTasks(sessionId) {\n        const newTaskList = [];\n        let modified = false;\n        this._prunedSessionIds.push(sessionId);\n        for (const task of this._tasksWaiting) {\n            if (task.sessionId !== sessionId) {\n                newTaskList.push(task);\n            }\n            else {\n                modified = true;\n            }\n        }\n        if (modified) {\n            this._tasksWaiting = newTaskList;\n        }\n    }\n    enqueueTask(task, prioritize = false) {\n        if (prioritize) {\n            this._priorityTasks.push(task);\n        }\n        else {\n            this._tasksWaiting.push(task);\n        }\n        this.runTasks();\n    }\n    runTasks() {\n        if (this._tasksWaiting.length + this._priorityTasks.length === 0 ||\n            this._currentConnectionCount >= this._maxConcurrentConnections) {\n            return;\n        }\n        while (this._tasksWaiting.length + this._priorityTasks.length !== 0 &&\n            this._currentConnectionCount < this._maxConcurrentConnections) {\n            this._currentConnectionCount++;\n            const task = this._priorityTasks.length > 0\n                ? this._priorityTasks.shift()\n                : this._tasksWaiting.shift();\n            Craft.sendActionRequest('POST', task.action, { data: task.params })\n                .then((response) => this.processSuccessResponse(response))\n                .catch(({ response }) => this.processFailureResponse(response))\n                .finally(() => {\n                if (task.callback) {\n                    task.callback();\n                }\n            });\n        }\n    }\n    _updateCurrentIndexingSession() {\n        for (const session of Object.values(this.indexingSessions)) {\n            if (session.getSessionStatus() !== SessionStatus.ACTIONREQUIRED) {\n                this._currentIndexingSession = session.getSessionId();\n                return;\n            }\n        }\n    }\n    /**\n     * Create a session from the data model.\n     *\n     * @param sessionData\n     * @private\n     */\n    createSessionFromModel(sessionData) {\n        return new AssetIndexingSession(sessionData, this);\n    }\n}\nclass AssetIndexingSession {\n    constructor(model, indexer) {\n        this.indexingSessionData = model;\n        this.indexer = indexer;\n    }\n    /**\n     * Get the session id\n     */\n    getSessionId() {\n        return this.indexingSessionData.id;\n    }\n    getProcessIfRootEmpty() {\n        return this.indexingSessionData.processIfRootEmpty;\n    }\n    getListEmptyFolders() {\n        return this.indexingSessionData.listEmptyFolders;\n    }\n    getProgressInfo() {\n        return `${this.indexingSessionData.processedEntries} / ${this.indexingSessionData.totalEntries}`;\n    }\n    /**\n     * Get the remaining entry count for this sessions.\n     */\n    getEntriesRemaining() {\n        return (this.indexingSessionData.totalEntries -\n            this.indexingSessionData.processedEntries);\n    }\n    /**\n     * Get the session status.\n     */\n    getSessionStatus() {\n        if (this.indexingSessionData.actionRequired) {\n            return SessionStatus.ACTIONREQUIRED;\n        }\n        if (this.indexer.currentIndexingSession === this.indexingSessionData.id) {\n            return SessionStatus.ACTIVE;\n        }\n        return SessionStatus.WAITING;\n    }\n    /**\n     * Create row html as a JQuery object based on an indexing sessions\n     * @param session\n     * @private\n     */\n    getIndexingSessionRowHtml() {\n        const $tr = $('<tr class=\"indexingSession\" data-session-id=\"' +\n            this.getSessionId() +\n            '\">');\n        const $td = $('<td/>').appendTo($tr);\n        const $ul = $('<ul/>').appendTo($td);\n        for (const volume of Object.values(this.indexingSessionData.indexedVolumes)) {\n            $('<li/>', {\n                text: volume,\n            }).appendTo($ul);\n        }\n        $tr.append('<td>' + this.indexingSessionData.dateCreated + '</td>');\n        const $progressCell = $('<td class=\"progress\"><div class=\"progressContainer\"></div></td>').css('position', 'relative');\n        const progressBar = new Craft.ProgressBar($progressCell.find('.progressContainer'), false, {\n            announceProgress: false,\n        });\n        progressBar.setItemCount(this.indexingSessionData.totalEntries);\n        progressBar.setProcessedItemCount(this.indexingSessionData.processedEntries);\n        progressBar.updateProgressBar();\n        progressBar.showProgressBar();\n        $progressCell.data('progressBar', progressBar);\n        $progressCell\n            .find('.progressContainer')\n            .append(`<div class=\"progressInfo\">${this.getProgressInfo()}</div>`);\n        $tr.append($progressCell);\n        $tr.append('<td>' + this.getSessionStatusMessage() + '</td>');\n        const $actions = this.getActionButtons();\n        $('<td></td>').append($actions).appendTo($tr);\n        return $tr;\n    }\n    /**\n     * Get action buttons for an indexing session\n     * @param session\n     * @private\n     */\n    getActionButtons() {\n        const $buttons = $('<div class=\"buttons\"></div>');\n        if (this.getSessionStatus() == SessionStatus.ACTIONREQUIRED) {\n            const reviewMessage = Craft.t('app', 'Review');\n            $buttons.append($('<button />', {\n                type: 'button',\n                class: 'btn submit',\n                title: reviewMessage,\n                'aria-label': reviewMessage,\n            })\n                .text(reviewMessage)\n                .on('click', (ev) => {\n                const $container = $(ev.target).parent();\n                if ($container.hasClass('disabled')) {\n                    return;\n                }\n                $container.addClass('disabled');\n                this.indexer.getReviewData(this);\n            }));\n        }\n        const discardMessage = Craft.t('app', 'Discard');\n        $buttons.append($('<button />', {\n            type: 'button',\n            class: 'btn submit',\n            title: discardMessage,\n            'aria-label': discardMessage,\n        })\n            .text(discardMessage)\n            .on('click', (ev) => {\n            if ($buttons.hasClass('disabled')) {\n                return;\n            }\n            $buttons.addClass('disabled');\n            this.indexer.stopIndexingSession(this);\n        }));\n        return $buttons;\n    }\n    /**\n     * Get the session status verbose message\n     *\n     * @param status\n     */\n    getSessionStatusMessage() {\n        switch (this.getSessionStatus()) {\n            case SessionStatus.ACTIONREQUIRED:\n                return Craft.t('app', 'Waiting for review');\n                break;\n            case SessionStatus.ACTIVE:\n                return Craft.t('app', 'Active');\n                break;\n            case SessionStatus.WAITING:\n                return Craft.t('app', 'Waiting');\n                break;\n        }\n    }\n    /**\n     * Return a list of missing entries for this session\n     */\n    getMissingEntries() {\n        return this.indexingSessionData.missingEntries;\n    }\n    /**\n     * Return a list of skipped entries for this session\n     */\n    getSkippedEntries() {\n        return this.indexingSessionData.skippedEntries;\n    }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","SessionStatus","IndexingActions","AssetIndexer","constructor","$indexingSessionTable","sessions","maxConcurrentConnections","this","_currentIndexingSession","_currentConnectionCount","_tasksWaiting","_priorityTasks","_prunedSessionIds","_currentlyReviewing","intervalAnnouncer","indexingSessions","_maxConcurrentConnections","reviewSessionId","sessionModel","session","createSessionFromModel","getSessionStatus","ACTIONREQUIRED","getSessionId","updateIndexingSessionData","_createProgressAnnouncer","_startProgressAnnouncer","performIndexingStep","currentIndexingSession","getCurrentSessionProgressInfo","getProgressInfo","indexingSession","renderIndexingSessionRow","$row","undefined","includes","find","remove","length","addClass","getIndexingSessionRowHtml","$existing","replaceWith","append","removeClass","discardIndexingSession","sessionId","runTasks","processFailureResponse","response","responseData","data","_updateCurrentIndexingSession","Craft","cp","displayError","message","stop","processSuccessResponse","skipDialog","reviewSession","getReviewData","task","action","OVERVIEW","params","callback","enqueueTask","_stopProgressAnnouncer","pruneWaitingTasks","$confirmBody","$","missingEntries","getMissingEntries","missingFiles","files","entries","missingFolders","folders","skippedFiles","getSkippedEntries","skippedFilesList","skippedFile","escapeHtml","t","haveMissingItems","id","uri","translationParams","items","missingItemsHeading","_getMissingItemsHeading","missingItemsCopy","_getMissingItemsCopy","$modal","appendTo","Garnish","$bod","$body","html","$footer","$buttons","modal","Modal","hideOnEsc","hideOnShadeClick","onHide","type","class","text","on","ev","preventDefault","stopIndexingSession","hide","initUiElements","updateSizeAndPosition","postData","getPostData","postParams","expandPostArray","FINISH","missingType","getListEmptyFolders","startIndexing","cb","sendActionRequest","START","then","catch","finally","IntervalManager","onInterval","announce","progress","_a","start","concurrentSlots","i","Math","min","getEntriesRemaining","PROCESS","getProcessIfRootEmpty","STOP","newTaskList","modified","push","prioritize","shift","values","sessionData","AssetIndexingSession","model","indexer","indexingSessionData","processIfRootEmpty","listEmptyFolders","processedEntries","totalEntries","actionRequired","ACTIVE","WAITING","$tr","$td","$ul","volume","indexedVolumes","dateCreated","$progressCell","css","progressBar","ProgressBar","announceProgress","setItemCount","setProcessedItemCount","updateProgressBar","showProgressBar","getSessionStatusMessage","$actions","getActionButtons","reviewMessage","title","$container","target","parent","hasClass","discardMessage","skippedEntries"],"sourceRoot":""}